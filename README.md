# Test assign for AppSecCamp by Antipov Vladislav

## Мои данные
Я: Антипов Владислав
Телефон: 89150007600
Почта: vmlantipov@gmail.com
ТГ: @kvant_crafter

## Задание 1

### 1. Расскажите, с какими задачами в направлении безопасной разработки вы сталкивались?
В основном эти задачи касались обработки пользовательского ввода и предотвращения таким образом разных инъекций.

### 2. Если вам приходилось проводить security code review или моделирование угроз, расскажите, как это было?
В рамках обучения в вузе на предметах, посвященных информационной безопасности веб-приложений на учебных виртуальных машинах мы моделировали угрозы как для уже развернутых локально приложений (каждый стенд был посвящен той или иной группе OWASP Top 10), так и для примеров кода backend-части приложения.

### 3. Если у вас был опыт поиска уязвимостей, расскажите, как это было?
На учебных курсах в Московской Школе Программистов и немного на первом курсе университета я занимался CTF, где в том числе были задания, связаные с уязвимостями веб-приложений.

### 4. Почему вы хотите участвовать в стажировке?
Мне очень интересен стык информационной безопасности и разработки ПО. Еще на курсах МШП будучи школьником я познакомился с обоими этими направлениями и очень ими заинтересовался. По итогу я решил получить образование по Информационной безопасности, однако и разработку веб-приложений не забросил, поэтому совместить эти два направления для меня было бы очень интересно.

## Задание 2

### Часть 1. Security code review: GO
В строке 38 некорректно формируется SQL-запрос - без каких-либо проверок, фильтрации или экранирования подставляется пришедшая из вне переменная. Подобное может привести к SQL-инъекции, с помощью которой злоумышленник сможет манипулировать данными из БД как угодно в зависимости от прав, из-под которых выполняется запрос.

Для решения проблемы стоит заменить 38 и 39 строчки на:
```
rows, err := db.Query("SELECT * FROM products WHERE name LIKE '%%?%%'", age)
```
То есть использовать плейсхолдеры вместо прямой вставки данных, благодаря чему SQL-запрос уже будет заранее сформирован, а входные данные никак на него повлиять не смогут.

### Часть 2: Security code review: Python
**Пример кода 1**

В строке 10 из шаблона, представляющего собой строку, скленную в том числе из переменных, полученных при запросе, рендерится html-страница.

Здесь сразу 2 проблемы:
1. Если параметр *name* не был передан, то согласно 8 строке в соответствующей переменной окажется None, что приведет к ошибке при попытке конкатинации ее и других строк в 10 строке.
2. Не проводится никакой валидации того, что за строки были переданы. Соответственно, при текущей генерации страницы вполне возможно совершить XSS атаку, внедрив в страницу вредоносный JS, iframe с вредоносным ресурсом, вредоносную форму и так далее.

Решение проблем:
1. Сделать аналогично строке 9, то есть передать вторым параметром функции *get* строковое значение по умочанию.
2. Необходима предобработка пришедших данных: кодирование, фильтрация, экранирование и другие подобные решения, чтобы при рендеринге они воспринимались как обычный текст, который не нужно выполнять.

**Пример кода 2**

В 8 строке мы можем получить в переменной *hostname* None, если параметр не был передан, что может привести к ошибке конкатинации в строке 9.

Если же все было передано, то в строке 10 открывается возможность для Command injection, так как входной парамерт никак не проверяется, что может привести к непредсказуемым последствиям в зависимости от того, под какими правами выполняется команда.

Решение проблем:
1. В 8 строке вторым параметром функции *get* передать строковое значение по умолчанию.
2. Так как мы выполняем команду *nslookup*, то нам точно известен шаблон входных данных, а именно доменное имя. Таким образом, мы можем составить регулярное выражение, проверящее, соответствует ли *hostname* этому шаблону, если да, то выполнять команду, если нет, то выводить сообщение о неуспешном выполнении команды.

## Задание 3

Я считаю, что некорректно отдавать backend сервисам обязанность взаимодействия с внешними пользователями, так как их главная задача - реализация логики приложения. При этом в случае каких-либо внешних атак они пострадают в первую очередь (например, упадут от перегрузки запросами), что может привести к сбою вcего приложения, так как именно - связующее звено между остальными частями. Любой простой приложения ведет к огромным убыткам компании и даже потери клиентов.

Между внешним миром и backend-сервисами должна быть DMZ, за которую будет отвечать веб-сервер (nginx, apache, uvicorn и другие), в чьи задачи будет входить:
1. Контроль доступа из внутренней сети во внешнюю и наоборот.
2. Фильтрация запросов, предотвращаущая атаки типа DOS или разведку внутренней сети
3. Балансировка нагрузки на сервисы

Вопросы для уточнения:
* Каким образом реализовано разделение прав, из-под которых выполняются запросы внутри сети (например, запросы к БД)?
* По защищенным ли каналам общаются все компоненты приложения в локальной сети?
